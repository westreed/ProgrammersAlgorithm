# 다익스트라 (Dijkstra)

다익스트라 (Dijkstra) 알고리즘은 <u>대표적인 최단 경로 길 찾기 알고리즘</u> 중 하나이다. 여러 문제에서 활용되며, 주로 하나의 정점에서부터 출발할 때에 사용할 수 있다. 다익스트라 알고리즘은 하나의 정점에서 모든 정점까지의 최단 거리를 구하는 알고리즘이기 때문이다.<br>

다익스트라알고리즘은 DP (DynamicProgramming)으로 분류되기도 그리디 (Greedy) 알고리즘에 분류되기도 하는데, 이는 전 최단 거리에서부터 값을 가져오는 특징과 항상 가장 가중치가 작은 노드를 선택한다는 특징 때문이다.

## BFS, DFS, 다익스트라의 시간복잡도 비교

먼저 간단하게 용어부터 정리하자.

* V : 그래프의 정점의 개수
* E : 각 정점에 연결되어 있는 간선의 개수

특정 노드에서 다른 노드까지의 거리를 인접리스트 BFS로 계산하게 되면, 현재 방문 중인 정점(V)에서 인접한 노드(E)만 방문하므로 `시간복잡도는 O(V+E)`가 된다. 인접행렬인 경우에는 `O(V^2)` 그리고 DFS도 같은 시간복잡도를 가진다.<br>

하지만 다익스트라 (Dijkstra) 알고리즘의 `시간복잡도는 O(V^2+E)`다. 여기서 우선순위 큐를 활용하면 `O(ElogE)`까지 복잡도를 내릴 수 있다. 물론, E가 V^E에 가까우면, 우선순위 큐는 활용하지 않는게 좋다.

## 그럼 다익스트라는 왜 필요할까?

자, 그러면 시간복잡도만 비교하면 다익스트라보다는 BFS나 DFS의 시간복잡도가 더 낮다는 걸 알 수 있는데 그럼에도 다익스트라를 활용하는 이유가 무엇일까?

BFS나 DFS는 간선에 가중치가 없는 경우에는 효율이 좋기 때문이다. 간선에 가중치가 있는 그래프문제라면 BFS, DFS의 시간복잡도는 기존보다 더 증가하게 된다.

## 다익스트라 알고리즘의 원리

이미지 자료 준비해서 넣기...


```python
INF = int(1e9)
N = 6
Graph = {0:[(1,3), (2,2), (3,5)], 1:[(2,2), (4,8)], 2:[(3,2)], 3:[(4,6)], 4:[(5,1)], 5:[]}
Dist = [INF] * N

def dijkstra(start):
    import heapq
    # (비용, 정점) 을 큐에 추가
    queue = [(0, start)]
    Dist[start] = 0

    while queue:
        dist, node = heapq.heappop(queue)

        # 저장된 거리보다 크면 넘기기
        if Dist[node] < dist: continue

        # 연결된 간선 중에서 비용이 낮은 경로 등록하기
        for nxt, cost in Graph[node]:
            _cost = Dist[node]+cost
            if Dist[nxt] <= _cost: continue
            Dist[nxt] = _cost
            heapq.heappush(queue, (Dist[nxt], nxt))

dijkstra(0)
print(Dist)
```