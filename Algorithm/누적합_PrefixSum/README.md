# 누적합 (Prefix Sum)

## 언제 필요할까?

1. 특정 구간 합을 필요로 할 때.
2. 반복문을 통한 구간 합으로는 통과가 어려울 때.

## 반복문 누적합의 한계

최대 10만개짜리 배열(N)에서, 최대 10만개의 질문(M)에 대해 i번째부터 j번째 까지의 합을 출력해야 한다. N개의 수를 입력받아둔 배열을 arr 이라고 할 때, 일반적으로 반복문을 사용해 답을 구한다면 다음과 같은 코드가 될 것이다.

```python
def RangeSum(arr, i, j):
    _sum = 0
    for idx in range(i, j+1):
        _sum += arra[idx]
    return _sum
```

1 <= i <= j <= N 이므로, 위 반복문은 최악의 경우 N번을 반복한다. > `O(N)` 그런데 여기서 M개의 누적합 질문에 대한 답을 구하고자 하면, `O(MN)` 이라는 시간복잡도가 필요하다. 이 때 N과 M은 모두 최대 100,000이므로 100억이라는 수치가 된다. 이는 보통 1억 번 정도의 시간복잡도를 1초로 잡게 되는데, 100억이므로 100초라는 시간을 소요하게 된다.

## 더 빠르게 구간합을 구하는 방법

사실, 매번 구간합을 반복문으로 구하는 과정만 생략해도 시간복잡도가 매우매우 낮아진다. 이는 일종의 Memoization한 방법이다. 바로, 미리 모든 구간합을 구하는 것이다. 하지만 이 구간합을 어떻게 저장하느냐가 또 중요하다.

그 방법은 각 index마다 0~index까지의 합을 저장하는 방식이다.

| index |   0  |   1  |   2  |   3  |   4  |   5  |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|  arr  |   7  |   3  |   8  |  12  |   4  |   2  |
|  sum  |   7  |  10  |  18  |  30  |  34  |  36  |

위와 같은 배열이 있을 때, 각 index마다 0번부터 현재 index까지의 합을 구해놓으면, 매우 쉽게 구간합을 구할 수 있게 된다.

예시로, 3~5번의 합을 구하고 싶을 때, `sum[5]-sum[2]`만 계산해주면 해당 구간합이 나오게 된다. 또한, 누적합을 미리 구하기 위해서 소요되는 시간복잡도는 `O(N)` 밖에 되지 않아서, 매우 빠르게 구간합을 구할 수 있게 된다.

```python
arr = [7, 3, 8, 12, 4, 2]

# 누적합
for i in range(1, len(arr)):
    arr[i] += arr[i-1]

# 3번~5번 구간합 구하기
print(arr[5]-arr[2])
```

## 문제 예제

### 누적합

* [이건 꼭 풀어야 해!](https://www.acmicpc.net/problem/17390)
* [나머지 합](https://www.acmicpc.net/problem/10986)
* [약수의 합](https://www.acmicpc.net/problem/17425)
* [큰 수 뒤집기](https://www.acmicpc.net/problem/23046)

### 2차원 누적합

* [주지수 문제](https://github.com/westreed/ProgrammersAlgorithm/blob/main/BAEKJOON/2Silver/주지수.py)